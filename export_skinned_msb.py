bl_info = {
	"name": "Export skinned SpellForce mesh (.msb/.bor)",
	"description": "Export skinned SpellForce mesh (.msb/.bor)",
	"author": "leszekd25",
	"blender": (2, 80, 0),
	"location": "Import/Export",
	"warning": "totally untested...", # used for warning icon and text in addons panel
	"category": "Import-Export",
}

import bpy
from bpy.props import (
	StringProperty,
	FloatProperty,
	IntProperty,
	BoolProperty,
	EnumProperty,
)
from bpy_extras.io_utils import (
	ImportHelper,
	ExportHelper,
	orientation_helper,
	axis_conversion,
)
from mathutils import *
from struct import unpack, pack
import os.path
	
class SFMap:
	def __init__(self):
		self.texID = -1		  #32 bit
		self.unknown1 = 0	  #8 bit
		self.texUVMode = 0	  #8 bit
		self.unused = 0		  #16 bit
		self.texRenderMode = 0#8 bit
		self.texAlpha = 1	  #8 bit
		self.flag = 7		  #8 bit
		self.depthbias = 0	  #8 bit
		self.tiling = 1.0	#float
		self.texName = ""	  #64 char string
	def set(self, table):
		print(table)
		self.texID = table[0]	  #always -1?
		self.unknown1 = table[1]  #idk
		self.texUVMode = table[2] #probably always 0
		self.unused = table[3]	  #anything goes here
		self.texRenderMode = table[4]	#depends, usually 0
		self.texAlpha = table[5]/255
		self.flag = table[6]	  #should be 7 except noted otherwise
		self.depthbias = table[7] #always 0?
		self.tiling = table[8]	  #always 1.0?
		ntable = []
		for c in table[9]:
			if c == 0:
				break
			ntable.append(c)
		self.texName = str(bytearray(ntable), "utf-8")
	def get(self):
		charray = []
		for i in range(64):
			if i >= len(self.texName):
				charray.append(0)
			else:
				charray.append(ord(self.texName[i]))
		charray = bytes(charray)
		return pack("1i2B1H4B1f64s", self.texID, self.unknown1, self.texUVMode, self.unused, self.texRenderMode, self.texAlpha, self.flag, self.depthbias, self.tiling, charray)

		
class SFMaterial:
	def __init__(self):
		self.texMain = SFMap()
		self.texSecondary = SFMap()
		self.diffCol = []
		self.emitCol = []
		self.specCol = []
		

# returns reference to a vertex from list if there is a vertex thats the same as input vert, none otherwise
def ContainsVert(list, vert):
	for v in list:
		if(v[0] == vert[0]) and (v[1][0] == vert[1][0]) and (v[1][1] == vert[1][1]):
			return v
	return None		

# reduces bone count to c, discarding least important bones and padding with 0s when needed
def reduce_bone_count(bi, bw, c):
	while(len(bi)>c):
		i = 0
		min_bw = bw[i]
		for j in range(len(bi)):
			if(bw[j]<min_bw):
				min_bw = bw[j]
				i=j
		del bi[i]
		del bw[i]
	while(len(bi)<c):
		bi.append(0)
		bw.append(0)

# probably could use the Vector class for that...
def normalize(bw):
	s = 0
	for b in bw:
		s+=b
	for i in range(len(bw)):
		bw[i] /= s
		bw[i] = int(bw[i]*255)

# not particularly fast, remaps bone indices to fit the required bone count
def recalculate_bone_indices(bi, bw, bsi_part):
	for i in range(len(bi)):
		if(bw[i] != 0):
			bi[i] = bsi_part.index(bi[i])

def SaveMSBSkinned(context, filepath):
	object = bpy.context.object
	obname=object.name
	mesh = object.data
	armature = object.parent
	skeleton = armature.data
	
	mesh.update()
	mesh.validate()
	
	# generate bone data
	bone_count = len(skeleton.bones)
	bone_pos = []
	bone_rot = []
	bone_parents = []
	
	if bpy.context.active_object:
		bpy.context.active_object.select_set(False)
	armature.select_set(True)
	bpy.context.view_layer.objects.active = armature
	bpy.ops.object.mode_set(mode='EDIT')

	# calculate bone state vectors
	for i in range(bone_count):
		bone = skeleton.edit_bones[i]
		bone_mat = bone.matrix
		if(bone.parent):
			bone_mat = bone.parent.matrix.inverted() @ bone.matrix
			for j, b in enumerate(skeleton.edit_bones):
				if(b == bone.parent):
					bone_parents.append(j)
					break
		else:
			bone_parents.append(-1)
		#print(bone_mat, bone_mat.to_translation(), bone_mat.to_quaternion())
		bone_pos.append(bone_mat.to_translation())
		bone_rot.append(bone_mat.to_quaternion())
	
	# find all vertices for each bone group (needed for skeleton file)
	vlist = []
	for i in range(bone_count):
		vlist.append([])
	for v in mesh.vertices:
		for g in v.groups:
			vlist[g.group].append([v.index, g.weight])
			
	# generate text data
	text_data = []
	text_data.append("// Generated by Blender MSB plugin\n")
	text_data.append("\n")
	text_data.append("[AnimData]\n")
	text_data.append("{\n")
	text_data.append("\tNOB = "+str(bone_count)+"\n")
	text_data.append("\tNOSV = 1\n")
	for i in range(bone_count):
		text_data.append("\t[B"+str(i)+"]\n")
		text_data.append("\t{\n")
		text_data.append("\t\tN = \""+skeleton.bones[i].name+"\"\n")
		text_data.append("\t\tId = "+str(i)+"\n")
		text_data.append("\t\tF = "+str(bone_parents[i])+"\n")
		text_data.append("\t\t[SV0]\n")
		text_data.append("\t\t{\n")
		text_data.append("\t\t\tT = 0.000000\n")
		text_data.append("\t\t\tP = {:f}, {:f}, {:f}\n".format(bone_pos[i][0], bone_pos[i][1], bone_pos[i][2]))
		text_data.append("\t\t\tRre = {:f}\n".format(bone_rot[i].w))
		text_data.append("\t\t\tRim = {:f}, {:f}, {:f}\n".format(bone_rot[i].x, bone_rot[i].y, bone_rot[i].z))
		for j, v in enumerate(vlist[i]):
			text_data.append("\t\t\t[V"+str(j)+"]\n")
			text_data.append("\t\t\t{\n")
			text_data.append("\t\t\t\tI = "+str(v[0])+"\n")
			text_data.append("\t\t\t\tP = 0.000000, 0.000000, 0.000000\n")	 # <- ???
			text_data.append("\t\t\t\tW = {:f}\n".format(v[1]))
			text_data.append("\t\t\t}\n")
			text_data.append("\n")
		text_data.append("\t\t}\n")
		text_data.append("\n")
		text_data.append("\t}\n")
		text_data.append("\n")
	text_data.append("}\n")
	text_data.append("")
	
	filepath2 = filepath.replace(".msb", ".bor")
	borfile = open(filepath2, 'w',)
	borfile.writelines(text_data)
	borfile.close()
	
	# export static mesh
	msbfile = open(filepath.replace(".msb", "")+".msb",'wb')
	modelnum = len(mesh.materials)
	
	triangles_per_material = [[] for i in range(modelnum)]
	for i, p in enumerate(mesh.polygons):
		# tpm[material_index] = [[index[v0], index[v1], index[v2]], [...], ...], v0, v1, v2 directly from blender mesh
		triangles_per_material[p.material_index].append([mesh.loops[i*3+0].vertex_index, mesh.loops[i*3+2].vertex_index, mesh.loops[i*3+1].vertex_index, i*3+0, i*3+2, i*3+1])
	#print(triangles_per_material)
	uv_layer = mesh.uv_layers[mesh.name]
	unique_verts_per_material = [[] for i in range(modelnum)]  # unique vert: [vertex index, unique uv]
	for i, tpm in enumerate(triangles_per_material):
		for j, t in enumerate(tpm):
			for k in range(3):
				#vert = [vertex index, uv for this vertex for this triangle, table of indices this vertex is referenced within this part of mesh]
				vert = [t[k], uv_layer.data[t[k+3]].uv, []]
				found_v = ContainsVert(unique_verts_per_material[i], vert)
				if(found_v == None):
					unique_verts_per_material[i].append(vert)
					vert[2].append(3*j+k)
				else:
					found_v[2].append(3*j+k)
	#print(unique_verts_per_material)
	
	# adjust material count to exclude empty meshbuffers
	mat_offset = 0
	for i in range(modelnum):
		if((len(unique_verts_per_material[i-mat_offset]) == 0) or (len(triangles_per_material[i-mat_offset]) == 0)):
			del unique_verts_per_material[i-mat_offset]
			del triangles_per_material[i-mat_offset]
			mat_offset += 1
	modelnum = len(unique_verts_per_material)

	# calculate bounding boxes for the parts of mesh
	bbox_per_model = [[10000, 10000, 10000, -10000, -10000, -10000] for i in range(modelnum)]
	bbox_total = [10000, 10000, 10000, -10000, -10000, -10000]
	
	for i in range(modelnum):
		for v in unique_verts_per_material[i]:
			pos = mesh.vertices[v[0]].co
			bbox_per_model[i][0] = min(bbox_per_model[i][0], pos[0])
			bbox_per_model[i][1] = min(bbox_per_model[i][1], pos[1])
			bbox_per_model[i][2] = min(bbox_per_model[i][2], pos[2])
			bbox_per_model[i][3] = max(bbox_per_model[i][3], pos[0])
			bbox_per_model[i][4] = max(bbox_per_model[i][4], pos[1])
			bbox_per_model[i][5] = max(bbox_per_model[i][5], pos[2])
			
	for i in range(modelnum):
		bbox_total[0] = min(bbox_total[0], bbox_per_model[i][0])
		bbox_total[1] = min(bbox_total[1], bbox_per_model[i][1])
		bbox_total[2] = min(bbox_total[2], bbox_per_model[i][2])
		bbox_total[3] = max(bbox_total[3], bbox_per_model[i][3])
		bbox_total[4] = max(bbox_total[4], bbox_per_model[i][4])
		bbox_total[5] = max(bbox_total[5], bbox_per_model[i][5])
		
		
	# write header
	outdata = pack("BBHBB", 0, 2, modelnum, 0, 0)
	msbfile.write(outdata)
	
	# data useful for BSI/skin calculation
	packed_vertices_per_material = [[] for i in range(modelnum)]
	packed_triangles_per_material = [[] for i in range(modelnum)]
	materials = []
	for i in range(modelnum):
		# write header
		outdata2 = pack("2b4H", 0, 2, len(unique_verts_per_material[i]), 0, len(triangles_per_material[i]), 0)
		msbfile.write(outdata2)
			
		ind_array = [0 for k in range(len(triangles_per_material[i])*3)]
		for k, v in enumerate(unique_verts_per_material[i]):
			for ix in v[2]:
				ind_array[ix] = k
		
		
		for v in unique_verts_per_material[i]:
			pos = mesh.vertices[v[0]].co
			normal = mesh.vertices[v[0]].normal
			col = [255, 255, 255, 255]
			uv = v[1]
			ind = v[0]
			packed_vertices_per_material[i].append([pos, normal, col, uv, ind])
			outdata3 = pack('6f4B2fI', pos[0], pos[1], pos[2], normal[0], normal[1], normal[2], col[0], col[1], col[2], col[3], uv[0], 1-uv[1], ind)
			msbfile.write(outdata3)
			
			
		for k in range(len(ind_array)//3):
			packed_triangles_per_material[i].append([ind_array[3*k+0], ind_array[3*k+1], ind_array[3*k+2]])
			outdata4 = pack("4H", ind_array[3*k+0], ind_array[3*k+2], ind_array[3*k+1], i)
			msbfile.write(outdata4)
		
		# handle materials
		material = SFMaterial()
		diffuse_color = mesh.materials[i].node_tree.nodes.get('Diffuse Color').outputs[0].default_value
		material.diffCol = [int(diffuse_color[2]*255), int(diffuse_color[1]*255), int(diffuse_color[0]*255), 255]
		specular_color = mesh.materials[i].node_tree.nodes.get('Specular Color').outputs[0].default_value
		material.specCol = [int(specular_color[2]*255), int(specular_color[1]*255), int(specular_color[0]*255), 255]
		material.emitCol = [0, 0, 0, 0]
		if mesh.materials[i].get('SFRenderMode') is not None:
			material.texMain.texRenderMode = mesh.materials[i]["SFRenderMode"]
		else:
			material.texMain.texRenderMode = 0
		if mesh.materials[i].get("SFFlags") is not None:
			material.texMain.flag = mesh.materials[i]["SFFlags"]
		else:
			material.texMain.flag = 7
		material.texMain.texAlpha = 255
		material.texMain.texName = mesh.materials[i].node_tree.nodes.get('Image Texture').image.name
		materials.append(material)
		# write to file
		msbfile.write(pack("2B", 0, 2))
		msbfile.write(material.texMain.get())
		msbfile.write(material.texSecondary.get())
		msbfile.write(pack("4B", material.diffCol[0], material.diffCol[1], material.diffCol[2], material.diffCol[3]))
		msbfile.write(pack("4B", material.emitCol[0], material.emitCol[1], material.emitCol[2], material.emitCol[3]))
		msbfile.write(pack("4B", material.specCol[0], material.specCol[1], material.specCol[2], material.specCol[3]))
		msbfile.write(pack("6f", bbox_per_model[i][0], bbox_per_model[i][1], bbox_per_model[i][2], bbox_per_model[i][3], bbox_per_model[i][4], bbox_per_model[i][5]))
		msbfile.write(pack("2f", 1.0, 0.0))
	
	msbfile.write(pack("6f", bbox_total[0],bbox_total[1],bbox_total[2],bbox_total[3],bbox_total[4],bbox_total[5]))
	msbfile.close()
	
	
	# SKIN+BSI GENERATION
	
	# generate list of bones per vertex
	bones_per_vertex = [[] for i in range(len(mesh.vertices))]
	for i, g in enumerate(vlist):	# i = bone index
		for v in g:	 # v = [vertex id, bone weight]
			bones_per_vertex[v[0]].append([i, v[1]])  # bones_per_vertex[v_id] = [[bone0, weight0], [bone1, weight1], ...]
	
	# find all bones used per material
	bones_per_material = [set() for i in range(modelnum)]
	for i in range(modelnum):
		for j, v in enumerate(packed_vertices_per_material[i]):
			#print(j, v)
			for w in bones_per_vertex[v[4]]:
				bones_per_material[i].add(w[0])
	
	# begin generating BSI
	# bsi will be splitting meshbuffers only if bonecount per meshbuffer > 20
	# how to split a meshbuffer:
	# 1. select first unselected triangle
	# 2. go down the list of triangles, selecting them and remembering all bones used by the triangle until their count reaches 20
	# 3. select all remaining triangles which only use marked bones
	# 4. generate new meshbuffer for each such set of triangles
	# 5. repeat until no more triangles
	# not a perfect algorithm, but it will get the work done, though i wonder how would it look on aryn skin for example
	# SpellForce does this much better, gotta investigate
	bsi = []
	batch_count = 0
	skin_packed_triangles_per_batch = []  # [material index, [triangles]]
	skin_packed_vertices_per_batch = []	  # [vertices]					   vertices contain bone info! bone info per vertex found in bones_per_vertex
	skin_packed_materials_per_batch = []
	
	for i, bpm in enumerate(bones_per_material):   # i - material index
		print("MATERIAL", i, "BONES", list(bpm))
		# vertex preprocessing
		for v in packed_vertices_per_material[i]:  # result: [pos, normal, bone_ind, uv, ind, bone_weight]
			# calculate bones
			bone_ind = []
			bone_ws = []
			for b in bones_per_vertex[v[4]]:
				bone_ind.append(b[0])
				bone_ws.append(b[1])
			reduce_bone_count(bone_ind, bone_ws, 3)
			normalize(bone_ws)
			v[2] = bone_ind
			v.append(bone_ws)
			
		# generating skin batches and BSI
		if(len(bones_per_material[i]) <= 20):
			# dont split, just pass data from packed meshbuffers
			# but first, final bone processing for BSI
			print("SPLITTING NOT NEEDED")
			bsi_part = []
			for b in bpm:
				bsi_part.append(b)
			print("BSI PART", bsi_part)
				
			skin_packed_vertices_per_batch.append([])
			for v in packed_vertices_per_material[i]:
				v2 = [[v[0][0], v[0][1], v[0][2]], [v[1][0], v[1][1], v[1][2]], [v[2][0], v[2][1], v[2][2]], [v[3][0], v[3][1]], v[4], [v[5][0], v[5][1], v[5][2]]]
				recalculate_bone_indices(v2[2], v2[5], bsi_part)
				skin_packed_vertices_per_batch[-1].append(v2)
				
			skin_packed_triangles_per_batch.append([i, []])
			for t in packed_triangles_per_material[i]:
				skin_packed_triangles_per_batch[-1][1].append(t)
				
			skin_packed_materials_per_batch.append(materials[i])
			
			bsi.append(bsi_part)
			batch_count += 1
		else:
			# ugh
			# 0. generate data required for algorithm to work
			print("SPLITTING REQUIRED")
			triangles_batch_index = [-1 for i in range(len(packed_triangles_per_material[i]))]	# -1 - unselected yet, x - selected in batch x
			triangles_selected_count = 0
			current_batch = 0
			bones_per_batch = []
			while True:
				print("BATCH", current_batch)
				first_triangle = -1
				# 1. select first unselected triangle
				for j in range(len(triangles_batch_index)):
					if(triangles_batch_index[j] == -1):
						first_triangle = j
						break
				# if triangle not found, stop here
				if(first_triangle == -1):
					print("NO MORE DATA, CANCELLING")
					break
				# 2. go down the list of triangles, selecting them and remembering all bones used by the triangle until their count reaches 20
				# only select triangles if its possible (so the bone count <= 20 at all times)
				# 3. select all remaining triangles which only use marked bones
				batch_bones = set()
				for j in range(first_triangle, len(packed_triangles_per_material[i])):
					t = packed_triangles_per_material[i][j]
					# get bones on this triangle
					current_triangle_bones = set()
					for k in range(3):
						v = packed_vertices_per_material[i][t[k]]
						for l in range(3):
							if v[5][l] != 0:
								current_triangle_bones.add(v[2][l])
					if(len(batch_bones | current_triangle_bones) <= 20):
						triangles_selected_count += 1
						triangles_batch_index[j] = current_batch
						batch_bones = batch_bones | current_triangle_bones
				bones_per_batch.append([])
				for b in batch_bones:
					bones_per_batch[-1].append(b)
				print("BONES THIS BATCH", bones_per_batch[-1])
				current_batch += 1
			
			# we have now triangle batches - all thats left is to generate BSI and meshbuffers
			for j in range(current_batch):
				print("PROCESSING BATCHES, BATCH", j)
				bsi_part = []
				for b in bones_per_batch[j]:
					bsi_part.append(b)
				print("BSI PART", bsi_part)
					
				vind_used = set()	   # indices in packed_vertices_per_material[i] used in this batch
				for k, p in enumerate(triangles_batch_index):
					if p == j:
						t = packed_triangles_per_material[i][k]
						for l in range(3):
							vind_used.add(t[l])
				vind_used = list(vind_used)
				vind_used.sort()
				
				vind_used_inverted = {}	   # if vind_used[X] = I, then vind_used_inverted[I] = X
				for k, p in enumerate(vind_used):
					vind_used_inverted[p] = k
				
				skin_packed_vertices_per_batch.append([])
				for k, v in enumerate(packed_vertices_per_material[i]):
					if k in vind_used_inverted:
						v2 = [[v[0][0], v[0][1], v[0][2]], [v[1][0], v[1][1], v[1][2]], [v[2][0], v[2][1], v[2][2]], [v[3][0], v[3][1]], v[4], [v[5][0], v[5][1], v[5][2]]]
						recalculate_bone_indices(v2[2], v2[5], bsi_part)
						skin_packed_vertices_per_batch[-1].append(v2)
				
				skin_packed_triangles_per_batch.append([i, []])
				for k, p in enumerate(triangles_batch_index):
					if p == j:
						t = packed_triangles_per_material[i][k]
						t2 = [vind_used_inverted[t[0]], vind_used_inverted[t[1]], vind_used_inverted[t[2]]]
						skin_packed_triangles_per_batch[-1][1].append(t2)
				
				skin_packed_materials_per_batch.append(materials[i])
				
				bsi.append(bsi_part)
				batch_count += 1
	
	# generate BSI file
	filepath3 = filepath.replace(".msb", ".bsi")
	bsifile = open(filepath3, 'wb',)
	
	bsifile.write(pack("I", len(bsi)))
	for i, bsi_part in enumerate(bsi):
		bsifile.write(pack("II", skin_packed_triangles_per_batch[i][0], len(bsi_part)))
		for j, b in enumerate(bsi_part):
			bsifile.write(pack("I", b))
	
	bsifile.close()
	
	batch_count = len(bsi)
	
	# calculate bounding boxes for the parts of skin
	bbox_per_model = [[10000, 10000, 10000, -10000, -10000, -10000] for i in range(batch_count)]
	
	for i in range(modelnum):
		for v in skin_packed_vertices_per_batch[i]:
			pos = v[0]
			bbox_per_model[i][0] = min(bbox_per_model[i][0], pos[0])
			bbox_per_model[i][1] = min(bbox_per_model[i][1], pos[1])
			bbox_per_model[i][2] = min(bbox_per_model[i][2], pos[2])
			bbox_per_model[i][3] = max(bbox_per_model[i][3], pos[0])
			bbox_per_model[i][4] = max(bbox_per_model[i][4], pos[1])
			bbox_per_model[i][5] = max(bbox_per_model[i][5], pos[2])
	
	# generate skin .msb file
	filepath4 = filepath.replace(".msb", "")+"_SKIN.msb"
	sknfile = open(filepath4, 'wb',)
	
	# write header
	outdata = pack("BBHBB", 0, 2, batch_count, 0, 0)
	sknfile.write(outdata)

	for i in range(batch_count):
		# write header
		outdata2 = pack("2b4H", 0, 2, len(skin_packed_vertices_per_batch[i]), 0, len(skin_packed_triangles_per_batch[i][1]), 0)
		sknfile.write(outdata2)
		
		for v in skin_packed_vertices_per_batch[i]:
			pos = v[0]
			normal = v[1]
			boneweight = v[5]
			uv = v[3]
			boneind = v[2]
			outdata3 = pack('6f4B2f4B', pos[0], pos[1], pos[2], normal[0], normal[1], normal[2], boneweight[0], boneweight[1], boneweight[2], 0, uv[0], 1-uv[1], boneind[0], boneind[1], boneind[2], 0)
			sknfile.write(outdata3)
			# write to file
		
		mat_ind = skin_packed_triangles_per_batch[i][0]
		for t in skin_packed_triangles_per_batch[i][1]:
			outdata4 = pack("4H", t[0], t[2], t[1], mat_ind)
			sknfile.write(outdata4)
		
		material = skin_packed_materials_per_batch[i]
		sknfile.write(pack("2B", 0, 2))
		sknfile.write(material.texMain.get())
		sknfile.write(material.texSecondary.get())
		sknfile.write(pack("4B", material.diffCol[0], material.diffCol[1], material.diffCol[2], material.diffCol[3]))
		sknfile.write(pack("4B", material.emitCol[0], material.emitCol[1], material.emitCol[2], material.emitCol[3]))
		sknfile.write(pack("4B", material.specCol[0], material.specCol[1], material.specCol[2], material.specCol[3]))
		sknfile.write(pack("6f", bbox_per_model[i][0], bbox_per_model[i][1], bbox_per_model[i][2], bbox_per_model[i][3], bbox_per_model[i][4], bbox_per_model[i][5]))
		sknfile.write(pack("2f", 1.0, 0.0))
	#write footer
	
	sknfile.write(pack("6f", bbox_total[0],bbox_total[1],bbox_total[2],bbox_total[3],bbox_total[4],bbox_total[5]))
	sknfile.close()
	
	return 0


class ExportSkinnedMSB(bpy.types.Operator, ExportHelper):
	"""Object Cursor Array"""
	bl_idname = "export.msb_skinned"
	bl_label = "Export SpellForce skinned mesh (.msb)"
	bl_options = {'REGISTER'}
	
	filepath: StringProperty(
		name="Output mesh",
		subtype='FILE_PATH'
		)

	filename_ext = ".msb"

	filter_glob: StringProperty(
			default="*.msb",
			options={'HIDDEN'},
			)
	
	@classmethod
	def poll(cls, context):
		obj = context.object
		return obj and obj.type == 'MESH' and obj.parent

	def execute(self, context):
		if SaveMSBSkinned(context, self.filepath) == 0:
			return {'FINISHED'}
		return {'CANCELLED'}



def menu_func(self, context):
	self.layout.operator(ExportSkinnedMSB.bl_idname, text="Export SpellForce skinned mesh (.msb)")


def register():
	bpy.utils.register_class(ExportSkinnedMSB)
	bpy.types.TOPBAR_MT_file_export.append(menu_func)

def unregister():
	bpy.utils.unregister_class(ExportSkinnedMSB)
	bpy.types.TOPBAR_MT_file_export.remove(menu_func)


if __name__ == "__main__":
	register()